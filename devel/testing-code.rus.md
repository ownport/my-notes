# Тестироварие кода

Материал ниже является выборкой на основании статей из раздела Links. Обработка материала не завершена.

## Проблемы с которыми сталкиваются при тестировании

### Медленные тесты

Требуется слишком много времени для выполнения теста. При разработке приложения, должна существовать возможность выполнять весь набор тестов (TestSuite) неограниченное количество раз и без необходимости ждать слишком долго. Весь набор модульных тестов приложения (конечно, если приложение не слишком большое) должен исполняться не дольше 1-2 минут. Тесты на модуль, находящий в разработке в данный момент должны срабатывать вообще мгновенно.

Почему это так важно:

 - Медленные тесты запускаются реже, из-за этого снижается отдача от тестов, ошибки находятся позднее, их исправление занимает много времени. Должна существовать возможность проверить все приложение при малейшем подозрении, что текущие изменения могут оказать влияние на другие части приложения.
 - Медленные тесты - это признак плохой изоляции тестируемого класса от других классов. 

### Хрупкие тесты

Тесты слишком часто ломаются при изменении кода. 

 - Чаще всего причиной этому становятся медленные тесты. Если полный набор тестов выполняется слишком долго, то скорее всего полные тесты будут запускаться реже, а чаще будут запускать тесты только для того кода, над которым работают в текущий момент. Если было изменено достаточно много кода и только потом выполнен общих набор тестов, то определить какие сделанные изменения привели к ошибкам достаточно сложно. Это и есть причина того, что разбираться становится сложно и утомительно. Вывод: запускайте тесты чаще и определить причины ошибок станет проще.
 - Неправильное тестирование. Тест «знает» слишком много деталей тестируемого кода, из-за этого при малейших изменениях в тестируемом коде тесты ломаются. Если вы меняете поведение класса, то изменение в тестах прогнозируемы. Если вы проводите рефакторинг кода без изменения функциональности, а тесты постоянно ломаются - значит есть повод подумать, как переделать тесты.
 - Еще одна причина - это дизайн системы, который не позволяет писать изолированные тесты. В этом случае винить тесты не стоит - они явно дают понять, что код требует рефакторинга.

### Сложный тест или тест-"спагетти"

Данная проблема часто возникает у разработчиков, которым не терпится протестировать некоторую функциональность досконально(и это не обвинение!), исчерпывающе проверяя всевозможные внутренние состояния. Самый лучший способ распознать такой код - посмотреть на тесты через некоторое время, скажем через неделю. Если тест на самом деле показателен, у вас не возникнет трудности с интерпретацией того, что же именно тестируется. Если же от количества частичных моков и странных проверок рябит в глазах, можно уверенно заявить, что перед вами тестовое «спагетти».

 - Тесты должны как можно меньше опираться на внутреннее состояние тестируемой сущности и скорее относится к ней, как к некоторому черному ящику. Таким образом можно ограничить от трудности дальнейшей поддержки и модификации тестов при рефакторинге кода.
 - Тесты должны тестировать модули именно так, как это будет делать остальной код в реальном приложении. Нет необходимости тестировать все мыслимые комбинации, если класс никогда не будет таким образом использован. Помните принцип YAGNI (You Aren't Gonna Need It).

### "Эхо в горах"

Если вы тестируете что-либо в одном месте и только в этом месте, тогда одна внесенная логическая ошибка в тестируемый код должна приводить к поломке только в одной части набора тестов. Но когда вы обнаруживаете, что исправление этой ошибки отражается на многих тестах, как говорится «словно эхо в горах», тогда ваш набор тестов содержит большой набор дублирующих друг друга проверок. При разработке тестов нужно четко представлять, что же именно вы тестируете, и избегать подобных дублирующих проверок, чтобы не создавать себе дополнительной работы. Помните основной принцип прагматичного программиста Don't repeat yourself - DRY. Если дублирующих проверок избежать не удается, тогда стоим задуматься о рефакторинге дизайна системы, которую вы тестируете.

P.S. Спорный вопрос. Если ошибка в одном месте кода, то должна быть сгенерирована ошибка и в тестах зависимого кода соответственно?


### Набор тестов не срабатывает без подключения к сети

При разработке приложений может потребоваться подключение к внешним приложениям. Это могут быть платежные системы, серверы аутентификации и т.д. Реальные взаимодействия с такими приложениями должны выполняеться в рамках системного тестирования. Такие тесты должны быть перенесены в приемочные тесты и исключены из набора модульных тестов.Это приводит к выделению классов, которые взаимодействуют с внешними ресурсами, снижению зависимостей от этих классов, использованию заглушек и моков. В идеале модульные тесты должны работать с консольном режиме, без web-сервера и базы данных (не обязательно), без дополнительных библиотек и проч. Там, где это можно и целесообразно, нужно использовать моки и заглушки. Такой подход позволит выполнять тесты с большой скоростью, однако есть шанс столкнуться с другой проблемой - чрезмерное доверие мокам.

### Чрезмерное доверие мокам

В случае, когда тестируемый код описан плотным кольцом моков и заглушек, то есть риск забыть про реальное применение класса и снова попасть в ловушку. Лежащие в основе использования моков идеи заключаются в том, что они действуют во многом именно так, как действовали бы реальные объекты. Если это не так (например, не полностью протестированы возможные комбинации взаимодействия, или же при настройке моков были допущены ошибки), а тестов с реальными классами недостаточно, тогда неизбежны ошибки.

Причина ошибок может заключатся в том, что тесты были изолированны моками, поведение которых уже более не соответствует реальному поведению классов, которые они заменяют.

Пути решения проблем:

 - Аккуратно использовать моки, только там, где это уместно.
 - Обязательно иметь в наличии функциональные тесты или модульные тесты высших уровней, которые реализованы без использования моков и заглушек. Путь эти тесты будут не такими подробными и быстрыми, зато они помогут отловить те ошибки, которые остались незамеченными при модульном тестировании.

### Недостаточное доверие мокам

Если реальные классы используются чаще в тестах, где тестируемый класс зависит от других классов, то это прямой путь получить раздутые, медленные и хрупкие тесты, которые часто ломаются, медленно работают и которые очень трудно писать и понимать. Явный признак - большой и сложный метод setUp().


## Links

 - [Запахи тестового кода](http://wiki.agiledev.ru/doku.php?id=tdd:smells)
 - [UnitTests, презентация](http://www.slideshare.net/antonkatkov/unit-tests-10054042)


