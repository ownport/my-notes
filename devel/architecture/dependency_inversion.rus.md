# Инверсия зависимостей

Инверсия зависимости (Dependency Inversion, далее DI) – это особый вид IoC (Inversion of Control, далее IoC), который применяется в Объектно-Ориентированном подходе для удаления зависимостей между классами. Зависимости между классами превращаются в ассоциации между объектами. Ассоциации между объектами могут устанавливаться и меняться во время выполнения приложения. Это позволяет сделать модули менее связанными между собой. 

## Принцип инверсии зависимостей

 1. Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба типа модулей должны зависеть от абстракций;
 2. Абстракция не должна зависеть от реализации. Реализация должна зависеть от абстракции.
 
Традиционные методы разработки (например, процедурное программирование) имеют тенденцию к созданию кода, в котором высокоуровневые модули, как раз, зависят от низкоуровневых. Это происходит из-за того, что одна из целей этих методов разработки – определение иерархии подпрограмм, а следовательно и иерархии вызовов внутри модулей (высокоуровневые модули вызывают низкоуровневые). Именно это является причиной низкой гибкости и закостенелости дизайна. 

## Формы инверсии зависимостей

Существует две формы инверсии зависимостей: активная и пассивная. Различие между ними состоит в том, как объект узнает о своих зависимостях во время выполнения.

При использовании пассивной формы зависимые объекты «впрыскиваются» в зависимый. Зависимому объекту не надо прилагать никаких усилий, все нужные сервисы он получает через свой интерфейс.

Активная форма, в отличии от пассивной, предполагает, что зависящий объект будет сам получать свои зависимости при помощи вспомогательных объектов.

Каждая из форм инверсии зависимостей имеет подтипы, которые характеризуют детали связывания объектов между собой.

Пассивная инверсия зависимостей:

 - constructor injection; Инъекция с помощью конструктора использует конструктор для ассоциирования объекта с конкретными реализациями абстракций. При использовании этого типа инверсии зависимостей, необходимые объекты передаются в конструктор, в качестве аргументов.
 
 - setter injection; Инъекция при помощи set-метода требует от вас определения отдельного set-метода для каждого из инъецируемых объектов. От предыдущего типа инъекции она отличается местом инъецирования. Construction injection и setter injection не исключают друг друга.
 
 - interface injection; Interface injection использует интерфейсы для осуществления связывания объектов. Во-первых, задаются интерфейсы, которые определяют методы для связывания. Один интерфейс на каждую зависимость. Зависимый объект должен реализовывать все эти интерфейсы. Определяется также единый интерфейс для всех сервисов. Каждый сервис реализует этот интерфейс таким образом, чтобы внедрить себя в зависящий объект. Таким образом, сервисы сами внедряют себя в зависимый объект посредством установленного интерфейса.
 
 - field injection; В некоторых языках программирования (Java/C#) существует возможность получить доступ к private/protected полям объекта. Эта техника может быть использована для внедрения сервисов в зависящий объект напрямую, без использования set-методов и конструкторов. 
 
Активная инверсия зависимостей (Dependency Lookup):

 - pull approach; Поиск зависимостей по методу pull approach предполагает наличие в системе общедоступного объекта, который знает обо всех используемых сервисах. 
 
 - push approach; Методика push approach отличается от pull approach тем, как модуль узнает об объекте. При использовании pull approach модуль сам получал локатор посредством метода-одиночки. Push approach характеризуется тем, что объект-локатор (или как его иногда называют context) передается в модуль извне.

## IoC Контейнеры

Очень важное понятие, связанное с инверсией зависимостей – это IoC контейнеры. IoC контейнер – это специальный объект-сборщик, который на основании схемы зависимостей между классами и абстракциями может создать граф объектов. Любой IoC контейнер реализует принцип инверсии зависимостей.

Наверное самым ярким примером использования IoC контейнеров является проект Spring. Это очень мощный проект, который затрагивает очень много аспектов конструирования ПО. Одним из таких аспектов является конструирование объектов на основании его связей. Причем связи между объектами могут храниться как в самом коде приложения, так и задаваться XML файлом.

Благодаря этому контейнер – конструктор может создать для вас объект с необходимыми зависимостями, которые определяют поведение системы.

## Dependency Injection: Active vs. Passive?

Между Active и Passive подходами есть различия, которые могут обусловить то, где более удачным будет применение той или иной формы инверсии зависимостей.

Ключевым отличием injection от lookup является то, как пользовательский объект связывается с объектом реализацией сервиса. При использовании injection объект получает необходимые сервисы неявно. Эти сервисы впрыскиваются в пользовательский объект контейнером-сборщиком или самим программистом. Если вы используете lookup подход, то ваш модуль должен явно запросить необходимые сервисы у локатора. Это различие во многом определяет разность между этими решениями.

Если вы используете контейнер-сборщик, то вы надежно прячете все зависимости, но не контролируете процесс впрыскивания зависимого объекта в ваш пользовательский. Это может в ряде случаев затруднить отладку приложения. Действительно, иногда трудно бывает понять причину ошибки, ведь поведение вашего объекта зависит не только от него самого, но и от того какие именно сервисы он использует.

Использование локатора ставит перед вами другую проблему. Локатор прячет за собой все зависимости, но появляется зависимость от самого локатора. Является ли эта зависимость для вас обременяющей? Как показывает практика, интерфейс локатора очень редко меняется, поэтому на это можно закрыть глаза. В действительности никто не боится зависимостей от классов, которые являются частью языковой платформы (например, DOMDocument).

Использование DI в чистом виде (без использования IoC-контейнеров) с одной стороны дает вам более понятный и предсказуемый код. В таком коде явно описываются зависимости объектов в данном контексте. Но такой метод ведет к излишней перегрузке интерфейса. Довольно часто количество необходимых сервисов превышает один – два объекта. Если вы будете передавать все зависимости объекта через его интерфейс вручную, то очень скоро вы станете испытывать сложности с сопровождением такого кода. Некоторые люди считают, что приложения, использующие IoC-контейнеры гораздо проще тестируются. Это не так. На самом деле тут нет практически никакой разницы между DL и DI. Довольно легко написать локатор, который будет давать возможность легко заменять сервисы mock или stub объектами. Это возможно как на уровне отдельных объектов (замена отдельного объекта), так и на уровне контейнера (замена всего контейнера или слияние нескольких контейнеров).

На самом деле, все эти методики не являются взаимоисключающими. Существуют проекты, которые удачно совмещают Dependency Injection и Dependency Lookup. Так что окончательное решение по поводу удачности этих решений в какой-либо вашей конкретной ситуации можете вынести только вы сами.

## Ссылки (for review)

 - [Инверсия управления](http://ru.wikipedia.org/wiki/%D0%98%D0%BD%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F)
 - [Принцип инверсии зависимости](http://blog.byndyu.ru/2009/12/blog-post.html)
 - [Принцип инверсии зависимости](http://www.handcode.ru/2010/02/blog-post.html)
 - [Принцип инверсии зависимости (Dependency Inversion Principle)](http://silverlight.su/viewtopic.php?id=166)
 - [Создание модульной структуры с применением инверсии управления](http://habrahabr.ru/search/?q=[%D0%B8%D0%BD%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F+%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B5%D0%B9]&target_type=posts)
 - [Принцип инверсии зависимости](http://www.gotdotnet.ru/blogs/AlexanderByndyu/6852/)

 - http://martinfowler.com/articles/injection.html
 - Фаулер, Скотт. UML. Основы. – СПб: Символ-Плюс, 2002.
 - http://www.objectmentor.com/resources/articleIndex
 - http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfObjectOrientedDesign
 - http://martinfowler.com/bliki/InversionOfControl.html

## Ссылки

 - [Инверсия зависимостей при проектировании Объектно-Ориентированных систем](http://wiki.agiledev.ru/doku.php?id=ooad:dependency_injection)
 - [Инъекция зависимостей](http://www.slideshare.net/ssuser2d8ea7/ss-7265323)
 
